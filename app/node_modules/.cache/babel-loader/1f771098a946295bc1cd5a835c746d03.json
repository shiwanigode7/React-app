{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _excluded = [\"canceled\", \"contentid\", \"overwrite\"];\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport Service from \"./Service\";\nimport { useState, useEffect, useCallback } from \"react\";\nvar useNodeBody = {\n  whitelist: [\"all\"]\n};\nexport var NOT_STARTED = \"NOT_STARTED\";\nexport var UPLOADING = \"UPLOADING\";\nexport var DONE = \"DONE\";\nexport var ERROR = \"ERROR\";\n\nvar RepoService = /*#__PURE__*/function (_Service) {\n  _inherits(RepoService, _Service);\n\n  var _super = _createSuper(RepoService);\n\n  function RepoService(url) {\n    _classCallCheck(this, RepoService);\n\n    return _super.call(this, \"repo\", url);\n  }\n  /**\r\n   * this hook uses useSWR (https://swr.vercel.app/) internally to fetch a node\r\n   * @param {String} nodeId of the node you want to fetch\r\n   * @param {Object} options to pass to useSWR\r\n   */\n\n\n  _createClass(RepoService, [{\n    key: \"useNode\",\n    value: function useNode(nodeId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (nodeId) {\n        if (typeof nodeId === \"string\") {\n          nodeId = nodeId.split(\"/\").map(decodeURIComponent);\n        }\n      } else {\n        nodeId = [undefined];\n      }\n\n      return this.usePost([\"NODE\", \"GET\", \"v1\"].concat(_toConsumableArray(nodeId)), useNodeBody, _objectSpread({\n        headers: {},\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false\n      }, options));\n    }\n    /**\r\n     * Hook to upload a file to a nodeid\r\n     * @param {String} nodeId \r\n     * @param {File} file the file to upload\r\n     * @param {Object} options object containing options\r\n     * \t\t\t\t\t\t\t- canceled, set to true to cancel the request\r\n     * \t\t\t\t\t\t\t- contentid, defaults to 'content'\r\n     * \t\t\t\t\t\t\t- overwrite, defaults to true\r\n     */\n\n  }, {\n    key: \"useUpload\",\n    value: function useUpload(nodeId, file) {\n      var _this = this;\n\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          canceled = _ref.canceled,\n          contentid = _ref.contentid,\n          _ref$overwrite = _ref.overwrite,\n          overwrite = _ref$overwrite === void 0 ? true : _ref$overwrite,\n          options = _objectWithoutProperties(_ref, _excluded);\n\n      var _useState = useState({\n        progress: 0,\n        status: NOT_STARTED\n      }),\n          _useState2 = _slicedToArray(_useState, 2),\n          _useState2$ = _useState2[0],\n          progress = _useState2$.progress,\n          status = _useState2$.status,\n          setState = _useState2[1];\n\n      useEffect(function () {\n        var abort = canceled;\n        var request;\n        setState(function (state) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            status: NOT_STARTED,\n            progress: 0\n          });\n        });\n\n        if (!abort && file && nodeId) {\n          var body = {\n            contentid: contentid,\n            overwrite: overwrite\n          };\n          var filteredBody = Object.keys(body).reduce(function (acc, key) {\n            return body[key] ? _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, body[key])) : acc;\n          }, {});\n\n          _this.post(\"/CONTENT/v0/\".concat(nodeId), undefined, {}, _objectSpread(_objectSpread({}, filteredBody), {}, {\n            s3uri: true,\n            originalFileName: file.name\n          })).then(function (_ref2) {\n            var contentUri = _ref2.contentUri,\n                statusUri = _ref2.statusUri;\n            if (abort) return;\n            request = new XMLHttpRequest();\n            request.upload.addEventListener(\"progress\", function (e) {\n              setState(function (state) {\n                return _objectSpread(_objectSpread({}, state), {}, {\n                  status: UPLOADING,\n                  progress: Math.ceil(e.loaded * 100 / e.total)\n                });\n              });\n            });\n            /**\r\n             * \r\n             * Apparently \"load\"/\"loadend\" or upload event listeners \r\n             * are not accurate indicators for 100% API completion \r\n             * one should use \"onreadystatechange\" to be 100% sure.\r\n             */\n\n            request.onreadystatechange = function () {\n              if (request.readyState === XMLHttpRequest.DONE) {\n                var _status = request.status;\n\n                if (_status >= 200 && _status < 400) {\n                  // The request has been completed successfully\n                  _this.post(statusUri, {\n                    status: \"completed\"\n                  });\n\n                  _this.put(\"/PROPERTY/v0/\".concat(nodeId, \"/fileName\"), {\n                    propertyType: \"string\",\n                    value: file.name,\n                    inherited: false,\n                    name: \"fileName\",\n                    id: \"fileName\"\n                  }, {}, {\n                    overwrite: 1\n                  });\n\n                  setState(function (state) {\n                    return _objectSpread(_objectSpread({}, state), {}, {\n                      status: DONE,\n                      progress: 100\n                    });\n                  });\n                }\n\n                request = null;\n              }\n            };\n\n            request.upload.addEventListener(\"error\", function () {\n              return setState(function (state) {\n                return _objectSpread(_objectSpread({}, state), {}, {\n                  status: ERROR\n                });\n              });\n            });\n            request.open(\"PUT\", contentUri);\n            request.setRequestHeader(\"Content-Type\", \"binary/octet-stream\");\n            request.send(file);\n          });\n        }\n\n        return function () {\n          request && request.abort();\n        };\n      }, [nodeId, canceled, contentid, overwrite, file]);\n      return {\n        progress: progress,\n        status: status\n      };\n    }\n  }]);\n\n  return RepoService;\n}(Service);\n\nexport { RepoService as default };","map":{"version":3,"sources":["D:/MPL_GitHUb/dbs-innovation/dbs-innovation/src/main/static/node_modules/@esko/cloud-service-utils/RepoService.js"],"names":["Service","useState","useEffect","useCallback","useNodeBody","whitelist","NOT_STARTED","UPLOADING","DONE","ERROR","RepoService","url","nodeId","options","split","map","decodeURIComponent","undefined","usePost","headers","revalidateOnFocus","revalidateOnReconnect","file","canceled","contentid","overwrite","progress","status","setState","abort","request","state","body","filteredBody","Object","keys","reduce","acc","key","post","s3uri","originalFileName","name","then","contentUri","statusUri","XMLHttpRequest","upload","addEventListener","e","Math","ceil","loaded","total","onreadystatechange","readyState","put","propertyType","value","inherited","id","open","setRequestHeader","send"],"mappings":"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","sourcesContent":["import Service from \"./Service\";\r\nimport { useState, useEffect, useCallback } from \"react\";\r\nconst useNodeBody = { whitelist: [\"all\"] };\r\n\r\nexport const NOT_STARTED = \"NOT_STARTED\";\r\nexport const UPLOADING = \"UPLOADING\";\r\nexport const DONE = \"DONE\";\r\nexport const ERROR = \"ERROR\";\r\nexport default class RepoService extends Service {\r\n\tconstructor(url) {\r\n\t\tsuper(\"repo\", url);\r\n\t}\r\n\r\n\t/**\r\n\t * this hook uses useSWR (https://swr.vercel.app/) internally to fetch a node\r\n\t * @param {String} nodeId of the node you want to fetch\r\n\t * @param {Object} options to pass to useSWR\r\n\t */\r\n\tuseNode(nodeId, options = {}) {\r\n\t\tif (nodeId) {\r\n\t\t\tif (typeof nodeId === \"string\") {\r\n\t\t\t\tnodeId = nodeId.split(\"/\").map(decodeURIComponent);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnodeId = [undefined];\r\n\t\t}\r\n\t\treturn this.usePost([\"NODE\", \"GET\", \"v1\", ...nodeId], useNodeBody, {\r\n\t\t\theaders: {},\r\n\t\t\trevalidateOnFocus: false,\r\n\t\t\trevalidateOnReconnect: false,\r\n\t\t\t...options\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Hook to upload a file to a nodeid\r\n\t * @param {String} nodeId \r\n\t * @param {File} file the file to upload\r\n\t * @param {Object} options object containing options\r\n\t * \t\t\t\t\t\t\t- canceled, set to true to cancel the request\r\n\t * \t\t\t\t\t\t\t- contentid, defaults to 'content'\r\n\t * \t\t\t\t\t\t\t- overwrite, defaults to true\r\n\t */\r\n\tuseUpload(nodeId, file, { canceled, contentid, overwrite = true, ...options } = {}) {\r\n\t\tconst [{ progress, status }, setState] = useState({ progress: 0, status: NOT_STARTED });\r\n\r\n\t\tuseEffect(() => {\r\n\t\t\tlet abort = canceled;\r\n\t\t\tlet request;\r\n\t\t\tsetState(state => ({ ...state, status: NOT_STARTED, progress: 0 }));\r\n\t\t\tif (!abort && file && nodeId) {\r\n\t\t\t\tconst body = { contentid, overwrite };\r\n\t\t\t\tconst filteredBody = Object.keys(body).reduce((acc, key) => (body[key] ? { ...acc, [key]: body[key] } : acc), {});\r\n\t\t\t\tthis.post(`/CONTENT/v0/${nodeId}`, undefined, {}, { ...filteredBody, s3uri: true, originalFileName: file.name }).then(({ contentUri, statusUri }) => {\r\n\t\t\t\t\tif (abort) return;\r\n\t\t\t\t\trequest = new XMLHttpRequest();\r\n\t\t\t\t\trequest.upload.addEventListener(\"progress\", e => {\r\n\t\t\t\t\t\tsetState(state => ({ ...state, status: UPLOADING, progress: Math.ceil((e.loaded * 100) / e.total) }));\r\n\t\t\t\t\t});\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * \r\n\t\t\t\t\t * Apparently \"load\"/\"loadend\" or upload event listeners \r\n\t\t\t\t\t * are not accurate indicators for 100% API completion \r\n\t\t\t\t\t * one should use \"onreadystatechange\" to be 100% sure.\r\n\t\t\t\t\t */\r\n\t\t\t\t\trequest.onreadystatechange = ()=> {\r\n\t\t\t\t\t\tif(request.readyState === XMLHttpRequest.DONE) {\r\n\t\t\t\t\t\t  let status = request.status;\r\n\t\t\t\t\t\t  if (status >= 200 && status < 400) {\r\n\t\t\t\t\t\t\t// The request has been completed successfully\r\n\t\t\t\t\t\t\tthis.post(statusUri, { status: \"completed\" });\r\n\t\t\t\t\t\t\tthis.put(\r\n\t\t\t\t\t\t\t\t`/PROPERTY/v0/${nodeId}/fileName`,\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tpropertyType: \"string\",\r\n\t\t\t\t\t\t\t\t\tvalue: file.name,\r\n\t\t\t\t\t\t\t\t\tinherited: false,\r\n\t\t\t\t\t\t\t\t\tname: \"fileName\",\r\n\t\t\t\t\t\t\t\t\tid: \"fileName\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{},\r\n\t\t\t\t\t\t\t\t{ overwrite: 1 }\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tsetState(state => ({ ...state, status: DONE, progress: 100 }));\r\n\t\t\t\t\t\t  }\r\n\t\t\t\t\t\t  request = null; \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest.upload.addEventListener(\"error\", () => setState(state => ({ ...state, status: ERROR })));\r\n\t\t\t\t\trequest.open(\"PUT\", contentUri);\r\n\t\t\t\t\trequest.setRequestHeader(\"Content-Type\", \"binary/octet-stream\");\r\n\t\t\t\t\trequest.send(file);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn () => {\r\n\t\t\t\trequest && request.abort();\r\n\t\t\t};\r\n\t\t}, [nodeId, canceled, contentid, overwrite, file]);\r\n\r\n\t\treturn { progress, status };\r\n\t}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}