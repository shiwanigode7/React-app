{"ast":null,"code":"var useEventBus = function useEventBus(_ref) {\n  var path = _ref.path,\n      _ref$delay = _ref.delay,\n      delay = _ref$delay === void 0 ? 0 : _ref$delay,\n      since = _ref.since;\n  var socketRef = \"\";\n  var callbacks = {};\n  var keepAlive = \"\";\n  var validSince = since && !isNaN(new Date(since).getTime()) ? since : undefined;\n  var calculatedSince = new Date().getTime(validSince); //url\n\n  var host = window.location.host.split(\".\");\n  host.splice(0, 1, \"\");\n  var wsProtocol = window.location.protocol.indexOf(\"https\") > -1 ? \"wss\" : \"ws\"; //const serviceURL = wsProtocol + \"://events\" + host.join(\".\") + \"/api/v1/subscribe/\" + path + \"?delay=5000\" + \"&since=\" + since.toString();\n\n  var serviceURL = \"\".concat(wsProtocol, \"://events\").concat(host.join(\".\"), \"/api/v1/subscribe/\").concat(path, \"?delay=\").concat(delay, \"&since=\").concat(calculatedSince, \"&filter=/indexed=true\");\n\n  var onClose = function onClose() {\n    clearInterval(keepAlive);\n\n    if (callbacks) {\n      Object.keys(callbacks).forEach(function (cbk) {\n        return socketRef.removeEventListener(\"message\", callbacks[cbk], true);\n      });\n    }\n  };\n\n  var close = function close() {\n    socketRef.close();\n    console.log(\"socket closed\");\n  };\n\n  var listen = function listen(callback, id) {\n    if (!Object.keys(callbacks).includes(id)) {\n      callbacks[id] = callback;\n      socketRef.addEventListener('message', callbacks[id], true);\n      return true;\n    } else {\n      console.log(\"id already exists\");\n      return false;\n    }\n  };\n\n  var stopListening = function stopListening(id) {\n    if (callbacks[id]) {\n      socketRef.removeEventListener('message', callbacks[id], true);\n      delete callbacks[id];\n    }\n  };\n\n  socketRef = new WebSocket(serviceURL);\n  socketRef.addEventListener('open', function (event) {\n    socketRef.addEventListener('close', onClose);\n\n    if (callbacks) {\n      Object.keys(callbacks).forEach(function (cbk) {\n        return socketRef.removeEventListener(\"message\", callbacks[cbk], true);\n      });\n      Object.keys(callbacks).forEach(function (cbk) {\n        return socketRef.addEventListener(\"message\", callbacks[cbk], true);\n      });\n    }\n\n    keepAlive = setInterval(function () {\n      if (socketRef.readyState === 1) {\n        socketRef.send(\"keepAlive\");\n      } else {\n        console.log(\"ws died\");\n      }\n    }, 30000);\n  });\n  var wsObject = {\n    socket: socketRef,\n    close: close,\n    listen: listen,\n    stopListening: stopListening\n  };\n  return wsObject;\n};\n\nexport default useEventBus;","map":{"version":3,"sources":["../../../../src/utils/hooks/useEventBus.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["const useEventBus = ({ path, delay = 0, since }) => {\n    let socketRef = \"\";\n    let callbacks = {};\n    let keepAlive = \"\";\n    const validSince = since && !isNaN(new Date(since).getTime()) ? since : undefined;\n    const calculatedSince = new Date().getTime(validSince);\n    //url\n    let host = window.location.host.split(\".\");\n    host.splice(0, 1, \"\");\n    const wsProtocol = window.location.protocol.indexOf(\"https\") > -1 ? \"wss\" : \"ws\";\n    //const serviceURL = wsProtocol + \"://events\" + host.join(\".\") + \"/api/v1/subscribe/\" + path + \"?delay=5000\" + \"&since=\" + since.toString();\n    const serviceURL = `${wsProtocol}://events${host.join(\".\")}/api/v1/subscribe/${path}?delay=${delay}&since=${calculatedSince}&filter=/indexed=true`;\n    const onClose = () => {\n        clearInterval(keepAlive);\n        if (callbacks) {\n            Object.keys(callbacks).forEach(cbk => socketRef.removeEventListener(\"message\", callbacks[cbk], true));\n        }\n    };\n    const close = () => {\n        socketRef.close();\n        console.log(\"socket closed\");\n    };\n    const listen = (callback, id) => {\n        if (!Object.keys(callbacks).includes(id)) {\n            callbacks[id] = callback;\n            socketRef.addEventListener('message', callbacks[id], true);\n            return true;\n        }\n        else {\n            console.log(\"id already exists\");\n            return false;\n        }\n    };\n    const stopListening = (id) => {\n        if (callbacks[id]) {\n            socketRef.removeEventListener('message', callbacks[id], true);\n            delete callbacks[id];\n        }\n    };\n    socketRef = new WebSocket(serviceURL);\n    socketRef.addEventListener('open', function (event) {\n        socketRef.addEventListener('close', onClose);\n        if (callbacks) {\n            Object.keys(callbacks).forEach(cbk => socketRef.removeEventListener(\"message\", callbacks[cbk], true));\n            Object.keys(callbacks).forEach(cbk => socketRef.addEventListener(\"message\", callbacks[cbk], true));\n        }\n        keepAlive = setInterval(() => {\n            if (socketRef.readyState === 1) {\n                socketRef.send(\"keepAlive\");\n            }\n            else {\n                console.log(\"ws died\");\n            }\n        }, 30000);\n    });\n    const wsObject = {\n        socket: socketRef,\n        close,\n        listen,\n        stopListening\n    };\n    return wsObject;\n};\nexport default useEventBus;\n//# sourceMappingURL=useEventBus.js.map"]},"metadata":{},"sourceType":"module"}