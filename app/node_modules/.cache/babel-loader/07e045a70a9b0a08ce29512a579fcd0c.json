{"ast":null,"code":"var _excluded = [\"query\", \"headers\"],\n    _excluded2 = [\"headers\", \"query\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport useSWR from \"swr\";\n\nvar serviceURL = function serviceURL(service) {\n  var host = window.location.host.split(\".\");\n  host.splice(0, 1, service);\n  return \"\".concat(window.location.protocol, \"//\").concat(host.join(\".\"));\n};\n\nvar methods = {\n  GET: \"GET\",\n  POST: \"POST\",\n  PUT: \"PUT\",\n  PATCH: \"PATCH\",\n  DELETE: \"DELETE\"\n};\n\nvar getQueryString = function getQueryString() {\n  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(query).map(function (key, index) {\n    var val = query[key];\n\n    var encode = function encode(key, val) {\n      return \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(val));\n    };\n\n    if (_typeof(val) === \"object\") {\n      // array (or object)\n      return (index === 0 ? \"?\" : \"\") + Object.keys(val).map(function (x) {\n        return encode(key, val[x]);\n      }).join(\"&\");\n    } else {\n      return (index === 0 ? \"?\" : \"\") + encode(key, val);\n    }\n  }).join(\"&\");\n};\n\nvar Service = /*#__PURE__*/function () {\n  function Service(service) {\n    var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : serviceURL(service);\n\n    _classCallCheck(this, Service);\n\n    this._url = url;\n    this._service = service;\n  }\n  /**\r\n   *\r\n   * @param {String} method\r\n   * @param {Array.<String> | String} pathSegments - An array of non encoded path segments or a single encoded path string\r\n   * @param {Object} [query]\r\n   * @param {Object} [body] JS object\r\n   * @param {Object} [headers]\r\n   */\n\n\n  _createClass(Service, [{\n    key: \"fetch\",\n    value: function (_fetch) {\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n\n      fetch.toString = function () {\n        return _fetch.toString();\n      };\n\n      return fetch;\n    }(\n    /*#__PURE__*/\n    _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var method,\n          pathSegments,\n          query,\n          body,\n          headers,\n          path,\n          queryStr,\n          response,\n          contentType,\n          _args = arguments;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              method = _args.length > 0 && _args[0] !== undefined ? _args[0] : \"GET\";\n              pathSegments = _args.length > 1 ? _args[1] : undefined;\n              query = _args.length > 2 ? _args[2] : undefined;\n              body = _args.length > 3 ? _args[3] : undefined;\n              headers = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};\n              path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\n              path = path.replace(/^\\//, \"\");\n              queryStr = getQueryString(query);\n              body = !body || typeof body === \"string\" ? body : JSON.stringify(body);\n              _context.next = 11;\n              return fetch(\"\".concat(this._url, \"/\").concat(path).concat(queryStr), {\n                method: method,\n                headers: headers,\n                body: body,\n                credentials: \"include\"\n              });\n\n            case 11:\n              response = _context.sent;\n              contentType = response.headers.get(\"content-type\");\n\n              if (!(response.status >= 400)) {\n                _context.next = 15;\n                break;\n              }\n\n              return _context.abrupt(\"return\", Promise.reject(response));\n\n            case 15:\n              if (!(contentType === \"application/json\")) {\n                _context.next = 19;\n                break;\n              }\n\n              return _context.abrupt(\"return\", response.json());\n\n            case 19:\n              if (!(contentType.indexOf(\"text\") > -1)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt(\"return\", response.text());\n\n            case 23:\n              return _context.abrupt(\"return\", response.blob());\n\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    })))\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n    /**\r\n     * Does a get request to this service\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} query - Object containing key value pairs for query parameters\r\n     * @param {Object} headers - Object containing header key value pairs\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(pathSegments, query, headers) {\n      return this.fetch(methods.GET, pathSegments, query, null, headers);\n    }\n    /**\r\n     *\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} jsonBody\r\n     * @param {Object} headers\r\n     * @param {Object} [query]\r\n     */\n\n  }, {\n    key: \"post\",\n    value: function post(pathSegments, jsonBody, headers, query) {\n      return this.fetch(methods.POST, pathSegments, query, jsonBody, _objectSpread({\n        \"Content-Type\": \"application/json\"\n      }, headers));\n    }\n    /**\r\n     *\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} jsonBody\r\n     * @param {Object} headers\r\n     * @param {Object} [query]\r\n     */\n\n  }, {\n    key: \"patch\",\n    value: function patch(pathSegments, jsonBody, headers, query) {\n      return this.fetch(methods.PATCH, pathSegments, query, jsonBody, _objectSpread({\n        \"Content-Type\": \"application/json\"\n      }, headers));\n    }\n    /**\r\n     *\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} jsonBody\r\n     * @param {Object} headers\r\n     * @param {Object} [query]\r\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(pathSegments, jsonBody, headers, query) {\n      return this.fetch(methods.PUT, pathSegments, query, jsonBody, _objectSpread({\n        \"Content-Type\": \"application/json\"\n      }, headers));\n    }\n    /**\r\n     *\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} jsonBody\r\n     * @param {Object} headers\r\n     * @param {Object} [query]\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(pathSegments, jsonBody, headers, query) {\n      return this.fetch(methods.DELETE, pathSegments, query, jsonBody, _objectSpread({\n        \"Content-Type\": \"application/json\"\n      }, headers));\n    }\n  }, {\n    key: \"useGet\",\n    value: function useGet(pathSegments) {\n      var _this = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          query = _ref2.query,\n          headers = _ref2.headers,\n          options = _objectWithoutProperties(_ref2, _excluded);\n\n      var path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\n      var queryStr = getQueryString(query);\n      var key = typeof pathSegments !== \"string\" && pathSegments.some(function (x) {\n        return x == undefined;\n      }) ? undefined : \"GET//\".concat(this._service, \"/\").concat(path).concat(queryStr);\n      return useSWR(key, function (url) {\n        return _this.get(url.replace(\"//\".concat(_this._service, \"/\"), \"\"), undefined, headers);\n      }, options);\n    }\n    /**\r\n     * A react hook to do a post call. Will return\r\n     * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n     * @param {Object} jsonBody\r\n     * @param {Object} options object containig headers and query objects\r\n     */\n\n  }, {\n    key: \"usePost\",\n    value: function usePost(pathSegments, jsonBody) {\n      var _this2 = this;\n\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          headers = _ref3.headers,\n          query = _ref3.query,\n          options = _objectWithoutProperties(_ref3, _excluded2);\n\n      var queryStr = getQueryString(query);\n      var path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\n      var key = typeof pathSegments !== \"string\" && pathSegments.some(function (x) {\n        return x == undefined;\n      }) ? undefined : \"POST//\".concat(this._service, \"/\").concat(path).concat(queryStr);\n      return useSWR([key, JSON.stringify(jsonBody), JSON.stringify(headers)], function (url, jsonBody, headers) {\n        return _this2.post(url.replace(\"POST//\".concat(_this2._service, \"/\"), \"\"), jsonBody, headers && JSON.parse(headers));\n      }, options);\n    }\n  }]);\n\n  return Service;\n}();\n\nexport { Service as default };","map":{"version":3,"sources":["D:/MPL_GitHUb/dbs-innovation/dbs-innovation/src/main/static/node_modules/@esko/cloud-service-utils/Service.js"],"names":["useSWR","serviceURL","service","host","window","location","split","splice","protocol","join","methods","GET","POST","PUT","PATCH","DELETE","getQueryString","query","Object","keys","map","key","index","val","encode","encodeURIComponent","x","Service","url","_url","_service","method","pathSegments","body","headers","path","replace","queryStr","JSON","stringify","fetch","credentials","response","contentType","get","status","Promise","reject","json","indexOf","text","blob","jsonBody","options","some","undefined","post","parse"],"mappings":"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","sourcesContent":["import useSWR from \"swr\";\r\nconst serviceURL = service => {\r\n\tconst host = window.location.host.split(\".\");\r\n\thost.splice(0, 1, service);\r\n\treturn `${window.location.protocol}//${host.join(\".\")}`;\r\n};\r\n\r\nconst methods = {\r\n\tGET: \"GET\",\r\n\tPOST: \"POST\",\r\n\tPUT: \"PUT\",\r\n\tPATCH: \"PATCH\",\r\n\tDELETE: \"DELETE\"\r\n};\r\n\r\nconst getQueryString = (query = {}) =>\r\n\tObject.keys(query)\r\n\t\t.map((key, index) => {\r\n\t\t\tconst val = query[key];\r\n\t\t\tconst encode = (key, val) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\r\n\t\t\tif (typeof val === \"object\") {\r\n\t\t\t\t// array (or object)\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(index === 0 ? \"?\" : \"\") +\r\n\t\t\t\t\tObject.keys(val)\r\n\t\t\t\t\t\t.map(x => encode(key, val[x]))\r\n\t\t\t\t\t\t.join(\"&\")\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\treturn (index === 0 ? \"?\" : \"\") + encode(key, val);\r\n\t\t\t}\r\n\t\t})\r\n\t\t.join(\"&\");\r\n\r\nexport default class Service {\r\n\tconstructor(service, url = serviceURL(service)) {\r\n\t\tthis._url = url;\r\n\t\tthis._service = service;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {String} method\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path segments or a single encoded path string\r\n\t * @param {Object} [query]\r\n\t * @param {Object} [body] JS object\r\n\t * @param {Object} [headers]\r\n\t */\r\n\tasync fetch(method = \"GET\", pathSegments, query, body, headers = {}) {\r\n\t\tlet path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\r\n\t\tpath = path.replace(/^\\//, \"\");\r\n\t\tconst queryStr = getQueryString(query);\r\n\r\n\t\tbody = !body || typeof body === \"string\" ? body : JSON.stringify(body);\r\n\t\tconst response = await fetch(`${this._url}/${path}${queryStr}`, { method, headers, body, credentials: \"include\" });\r\n\t\tconst contentType = response.headers.get(\"content-type\");\r\n\t\tif (response.status >= 400) {\r\n\t\t\treturn Promise.reject(response);\r\n\t\t}\r\n\t\tif (contentType === \"application/json\") {\r\n\t\t\treturn response.json();\r\n\t\t} else if (contentType.indexOf(\"text\") > -1) {\r\n\t\t\treturn response.text();\r\n\t\t} else {\r\n\t\t\treturn response.blob();\r\n\t\t}\r\n\t}\r\n\r\n\tget url() {\r\n\t\treturn this._url;\r\n\t}\r\n\t/**\r\n\t * Does a get request to this service\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} query - Object containing key value pairs for query parameters\r\n\t * @param {Object} headers - Object containing header key value pairs\r\n\t */\r\n\tget(pathSegments, query, headers) {\r\n\t\treturn this.fetch(methods.GET, pathSegments, query, null, headers);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} jsonBody\r\n\t * @param {Object} headers\r\n\t * @param {Object} [query]\r\n\t */\r\n\tpost(pathSegments, jsonBody, headers, query) {\r\n\t\treturn this.fetch(methods.POST, pathSegments, query, jsonBody, {\r\n\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t...headers\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} jsonBody\r\n\t * @param {Object} headers\r\n\t * @param {Object} [query]\r\n\t */\r\n\tpatch(pathSegments, jsonBody, headers, query) {\r\n\t\treturn this.fetch(methods.PATCH, pathSegments, query, jsonBody, {\r\n\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t...headers\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} jsonBody\r\n\t * @param {Object} headers\r\n\t * @param {Object} [query]\r\n\t */\r\n\tput(pathSegments, jsonBody, headers, query) {\r\n\t\treturn this.fetch(methods.PUT, pathSegments, query, jsonBody, {\r\n\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t...headers\r\n\t\t});\r\n\t}\r\n\t/**\r\n\t *\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} jsonBody\r\n\t * @param {Object} headers\r\n\t * @param {Object} [query]\r\n\t */\r\n\tdelete(pathSegments, jsonBody, headers, query) {\r\n\t\treturn this.fetch(methods.DELETE, pathSegments, query, jsonBody, {\r\n\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t...headers\r\n\t\t});\r\n\t}\r\n\tuseGet(pathSegments, { query, headers, ...options } = {}) {\r\n\t\tconst path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\r\n\t\tconst queryStr = getQueryString(query);\r\n\t\tconst key =\r\n\t\t\ttypeof pathSegments !== \"string\" && pathSegments.some(x => x == undefined) ? undefined : `GET//${this._service}/${path}${queryStr}`;\r\n\t\treturn useSWR(key, url => this.get(url.replace(`//${this._service}/`, \"\"), undefined, headers), options);\r\n\t}\r\n\r\n\t/**\r\n\t * A react hook to do a post call. Will return\r\n\t * @param {Array.<String> | String} pathSegments - An array of non encoded path strings or a single encoded path string\r\n\t * @param {Object} jsonBody\r\n\t * @param {Object} options object containig headers and query objects\r\n\t */\r\n\tusePost(pathSegments, jsonBody, { headers, query, ...options } = {}) {\r\n\t\tconst queryStr = getQueryString(query);\r\n\t\tconst path = typeof pathSegments === \"string\" ? pathSegments : pathSegments.map(encodeURIComponent).join(\"/\");\r\n\t\tconst key =\r\n\t\t\ttypeof pathSegments !== \"string\" && pathSegments.some(x => x == undefined) ? undefined : `POST//${this._service}/${path}${queryStr}`;\r\n\t\treturn useSWR(\r\n\t\t\t[key, JSON.stringify(jsonBody), JSON.stringify(headers)],\r\n\t\t\t(url, jsonBody, headers) => this.post(url.replace(`POST//${this._service}/`, \"\"), jsonBody, headers && JSON.parse(headers)),\r\n\t\t\toptions\r\n\t\t);\r\n\t}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}